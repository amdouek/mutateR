---
title: "mutateR"
author: "Alon M Douek"
date: "`r Sys.Date()`"
output: 
  github_document:
    toc: true
always_allow_html: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Overview

`mutateR` streamlines design of frame-aware CRISPR/Cas-mediated deletions.

It identifies pairs of non-contiguous exons in a given transcript that are phase-compatible with each other (*i.e.*, pairs of exons that do not normally neighbour each other in the transcript, but the 5' exon ends in the same reading frame position (0, 1, or 2) as the 3' exon begins with).

### Background

The underlying motivation is to facilitate the generation of mutant alleles that are not prone to nonsense-mediated decay (NMD), which can induce transcriptional adaptive responses ([El-Brolosy et al., *Nature* (2019)](https://doi.org/10.1038/s41586-019-1064-z "Genetic compensation triggered by mutant mRNA degradation") and [Ma et al., Nature (2019)](https://www.nature.com/articles/s41586-019-1057-y "PTC-bearing mRNA elicits a genetic compensation response via Upf3a and COMPASS components")). This behaviour can attenuate the phenotypic potency of mutant alleles, making the study of gene loss-of-function more difficult.

NMD is a complex process that cells use to survey and degrade transcripts that contain a premature termination codon (PTC). This generally occurs when a mutation causes a frameshift, resulting in a termination codon being introduced in a non-terminal exon. During splicing of mature mRNA, exon junction protein complexes (EJCs) are deposited at exon-exon junctions; during translation, the ribosome displaces these complexes. If a ribosome encounters a PTC **at least 50 nucleotides** upstream of the last exon-exon junction, it will fail to displace any downstream EJCs. The remaining EJC(s) will interact with termination factors to induce decay of the PTC-bearing transcript.

While the degradation of PTC-bearing mRNAs protects the cell from producing potentially toxic truncated proteins, the mRNA fragments that result from NMD can induce upregulation of other ('adapting') genes. This effect is a compensatory behaviour termed *'transcriptional adaptation'*, and can cause masking of gene loss-of-function phenotypes.

### Why does this matter?

Suppose you are studying a novel gene of interest ('A'). Gene A is expressed in the brain, and you hypothesise that loss of Gene A causes a brain growth phenotype. When you knock down expression of Gene A in your model organism of choice, you see the expected stunting of brain development; however, when you look at the brains of animals homozygous for a frameshift mutation causing a PTC early in the gene, the brains look normal. Gene A is functionally related to, and expressed in the same region as, another gene ('B'). When you measure expression of Gene A and Gene B in these brains, you see little to no Gene A expression, but Gene B is expressed at higher levels than in brains from animals that do not have this mutation. This is because Gene B has compensated for the loss of Gene A by responding to the mRNA fragments produced by NMD of the Gene A transcript. While this is *great* for the animal (it has a largely "normal" brain!), it means that we can't really use our Gene A mutant to reliably study the effects of loss of Gene A function.

### How can we prevent this?

In short, **use tools for targeted mutagenesis to their strengths**. Back when the only way to make a mutant animal was to randomly mutagenise its genome and then recover alleles based on phenotypes, researchers didn't have a great deal of control over the nature of the resulting alleles. Modern sequence-targeting methods (such as CRISPR/Cas9) allow for much more control over the nature of the mutations that we can generate.

If we delete parts of a gene that correspond to functional domains of the encoded protein, but maintain the original reading frame (such that there is no PTC**\***), we are left with a stably-expressed, truncated mutant transcript that does not encode a functional protein but also does not induce transcriptional adaptation via NMD.

> *\*Note*: There is nuance to NMD induction. For example, PTCs are much better tolerated (*i.e.*, do not induce NMD) if they occur in the transcript's terminal exon. For an excellent quantitative study of NMD induction relative to transcript PTC position, please see [Lindeboom, Supek and Lehner, *Nature Genetics* (2016)](https://doi.org/10.1038/ng.3664 "The rules and impact of nonsense-mediated mRNA decay in human cancers").

This type of deletion can be achieved by simultaneously targeting two sites in the gene of interest; the intervening region between the two targeted sites will be excised, and the ends of the genetic lesion are joined together by DNA repair mechanisms.

## How does `mutateR` work?

`mutateR` uses `biomaRt` to retrieve transcript and exon phase information for your gene of interest, then calculates which pairs of non-contiguous exons are phase-compatible. It then scans these exons for Cas effector PAMs (currently Cas9 NGG and Cas12a TTTV) associated with protospacers that do not cross exon boundaries. After calculating on-target scores for potential gRNAs using rule sets from `crisprScore` ([Hoberecht et al., *Nature Communications* (2022)](https://www.nature.com/articles/s41467-022-34320-7 "A comprehensive Bioconductor ecosystem for the design of CRISPR guide RNAs across nucleases and technologies")), `mutateR` returns recommended gRNA pairs to target exons where the flanking exons are in-frame with each other. It also produces a graphical representation of the selected transcript, its phase-compatible exons, and the recommended exon pairs for targeting.

The `mutateR` package consists of the following ordered functions:

| Step | Function | Functionality |
|-------------------|---------------------------|---------------------------|
| 1 | `get_gene_info()` | Query Ensembl for gene and transcript metadata. |
| 2 | `get_exon_structures()` | Retrieve exon coordinates and phase metadata. |
| 3 | `find_cas9_sites()`/`find_cas12a_sites()` | Identify nuclease recognition sites. |
| 4 | `check_exon_phase()` | Determine phase-compatible exon pairs. |
| 5 | `check_frameshift_ptc()` | Calculate and flag frameshift/PTC consequences. |
| 6 | `map_protein_domains()` | Retrieve protein domain annotations from InterPro corresponding to exons. |
| 7 | `score_gRNAs()` | Score guide RNAs via `crisprScore`. |
| 8 | `filter_valid_gRNAs()` and `assemble_gRNA_pairs()` | Filter allowed gRNA pairs and assemble into a readable data.frame. |
| 9 | `plot_gRNA_design()` | Visualise phase compatibility of non-contiguous exon pairs and top-ranked valid gRNA pairs. |
| 10 | `plot_grna_heatmap()` | For large gene (\>12 exons) visualisation - helper function for `plot_grna_design()` but can be executed separately. |
| 11 | `run_mutateR()` | Wrapper; runs entire pipeline. |

`mutateR` also has an additional function, `design_gRNA_pairs()`, that is not included in the wrapper function. This function can be used in isolation to produce a data.frame of gRNA pairs for the gene of interest.

## Getting started

### Installation

Currently, `mutateR` can be installed from GitHub:

```{r install, eval=FALSE}
devtools::install_github("amdouek/mutateR")
library(mutateR)
```

Running `mutateR` requires only installation of the package itself, and that you have also installed the `BSgenome` R package for your species of interest (e.g., `BSgenome.Hsapiens.UCSC.hg38` for human). These BSgenome data packages can be quite large, so are not installed alongside `mutateR`.

> For convenience's sake, here are the Bioconductor pages to install the genomes for commonly-used species:
>
> -   [human (hg38)](https://doi.org/doi:10.18129/B9.bioc.BSgenome.Hsapiens.UCSC.hg38),
>
> -   [mouse (mm10)](https://doi.org/doi:10.18129/B9.bioc.BSgenome.Mmusculus.UCSC.mm10),
>
> -   [rat (rn7)](https://doi.org/doi:10.18129/B9.bioc.BSgenome.Rnorvegicus.UCSC.rn7),
>
> -   [zebrafish (danRer11)](https://doi.org/doi:10.18129/B9.bioc.BSgenome.Drerio.UCSC.danRer11),
>
> -   [*Drosophila melanogaster* (dm6)](https://doi.org/doi:10.18129/B9.bioc.BSgenome.Dmelanogaster.UCSC.dm6)
>
> -   [*Caenorhabditis elegans* (ce11)](https://bioconductor.org/packages/release/data/annotation/html/BSgenome.Celegans.UCSC.ce11.html)
>
> You can also see all genomes currently available through `BSgenome` by running `BSgenome::available.genomes()`.

In the below example run, we will run `mutateR` on human *TP53* to select optimal Cas9 gRNA pairs*.* Assuming you have installed both `mutateR` and your BSgenome of choice (in this case, human):

```{r, message=FALSE}
library(mutateR)
library(BSgenome.Hsapiens.UCSC.hg38)
```

## Minimal `mutateR` workflow

The wrapper function `run_mutateR()` executes the full pipeline (using the canonical transcript by default). For human *TP53:*

```{r}
tp53_res <- run_mutateR(
  gene_id = "TP53",
  species = "hsapiens",
  genome = BSgenome.Hsapiens.UCSC.hg38,
  nuclease = "Cas9",
  score_method = 'ruleset1',
  top_n = NULL,
  quiet = FALSE,
  )
```

> Note that this function also reports a PAM distribution. In the case of *TP53*, CGG PAMs are significantly underrepresented amongst those identified by `mutateR`, as is generally expected in the human exome (see [Yang, Zhu and Jin, *BMC Genomics* (2024)](https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-024-11073-9) and [Scott and Zhang, *Nature Medicine* (2017)](https://pmc.ncbi.nlm.nih.gov/articles/PMC5749234/)).

The object `tp53_res` is a list with the following levels:

```{r}
names(tp53_res)
```

With the actual selected gRNA pairs (with associated metadata) stashed as a data.frame in `tp53_res$pairs`.

```{r}
kableExtra::scroll_box(knitr::kable(head(tp53_res$pairs,5)),width = '700px')
```

By default, all pairs are present in this data.frame; if you are interested in only those that `mutateR` recommends, simply filter for `recommended == TRUE`.

```{r}
tp53_recommended <- filter(tp53_res$pairs, tp53_res$pairs$recommended == TRUE)
kableExtra::scroll_box(knitr::kable(head(tp53_recommended,5)),width = '700px')
```

### Interpreting the `run_mutateR()` output

##### The `pairs` data.frame:

`upstream_exon` and `downstream_exon` refer to the two phase-compatible exons, while `exon_5p` and `exon_3p` refer to the 5-prime and 3-prime exons to simultaneously target using the selected gRNAs in that row of the data.frame.

The `compatible` flag (`run_mutateR()` currently only returns compatible exon pairs) highlights if the exon pair is phase-compatible; if a non-compatible exon pair were used, one might expect the `frameshift` and `ptc_flag` values to be `TRUE`. The `terminal_exon_case` flag is used for a special case, where a frameshift has introduced a PTC into the terminal exon of the selected transcript. Final-exon PTCs induce NMD with far lower efficiency than those in non-terminal exons, and are significantly less likely to result in transcriptional compensatory behaviour.

The actual gRNA protospacer sequences are given in `protospacer_sequence_5p` and `protospacer_sequence_3p` (with 5p and 3p referring to the relative position in the transcript), and the corresponding PAMs in `pam_sequence_5p` and `pam_sequence_3p` respectively.

> Note that while both + and - strands are scanned for PAMs, the - strand sequences are automatically reverse-complemented so will always display NGG PAMs (instead of CCN).

Each 5-prime and 3-prime gRNA sequence also has corresponding `ontarget_score`, `start` and `end` metadata. The `ontarget_score` relates to whatever scoring method you selected when executing `run_mutateR()`, while `start` and `end` are the genomic coordinates of the start and end of the protospacer sequence.

`domains` contains protein domain annotations corresponding to the selected exon pairs derived from the `map_protein_domains()` function, while the `recommended` flag is `TRUE` if the gRNA pair meets all validity criteria (including both gRNAs passing the on-target scoring threshold).

##### Visualisation

`mutateR` also produces a basic visualisation for both phase-compatibility of non-contiguous exons as well as the exons to be targeted by recommended gRNA pairs (the nature of this visualisation will change once I figure out how to make it less shit):

```{r mutateR_plot, fig.width=8, fig.height=6}
tp53_res$plot
```

For larger genes (defined - somewhat arbitrarily - here as \>12 exons), the above arc-based visualisation gets quite cluttered. If a transcript with \>12 exons is used to run `run_mutateR()`, the visualisation type will automatically switch to a heatmap/matrix-based output. This might become the default mode in future, if I can make it more informative vis-a-vis recommended gRNA pairs (TBC).

To give an example of the above, let's run `mutateR` with a sufficiently large gene - in this case, zebrafish *frmpd3* (17 exons total, of which the first two contain 5\` UTR):

```{r}
library(BSgenome.Drerio.UCSC.danRer11)

frmpd3 <- run_mutateR(gene_id = 'frmpd3',
                     species = 'drerio',
                     genome = BSgenome.Drerio.UCSC.danRer11,
                     nuclease = 'Cas9',
                     score_method = 'ruleset1')
```

```{r mutateR_plot2, fig.width=8, fig.height=6}
frmpd3$plot
```

The x-axis represents the 5-prime exon, and the y-axis the three-prime exon, to represent a given exon pair. UTR-containing exons are in red, contiguous exons in green, while non-contiguous phase-compatible exons are in yellow. All incompatible exon pairs are blue.

##### Other data levels

The `run_mutateR()` output also contains two GRanges objects: `exons` and `scored_grnas`.

`exons` contains the exon metadata (coordinates, strand, phase, length, etc.):

```{r}
head(tp53_res$exons,5)
```

While `scored_grnas` contains the complete set of (unpaired) gRNAs, their genomic coordinates, and the on-target score. The `sequence_context` column is the protospacer + PAM as well as the flanking nucleotides required for scoring (according to `crisprScore::scoringMethodsInfo`) based on the selected scoring method.

```{r}
head(tp53_res$scored_grnas,5)
```

### Special cases

#### Small genes

Given that NMD induction requires persistence of EJCs, genes with one or two exons tend to not be quite as prone to this mode of transcriptional adaptive response. However, we still want these types of genes to be able to be processed by `mutateR`, which will automatically recognise these edge cases if you provide such a gene (or a specific transcript with only 1-2 exons).

Instead of computing exon phase compatibility (which isn't a factor for these types of gene), the pipeline instead prioritises providing the user with gRNA pairs that 1) score well per the applied on-target method, and 2) produce a known (approximate) deletion size.

Here's an example with zebrafish *opn4.1*, which contains a single, large coding exon):

```{r}
opn4.1 <- run_mutateR(gene_id = 'opn4.1',
                     species = 'drerio',
                     genome = BSgenome.Drerio.UCSC.danRer11,
                     nuclease = 'Cas9',
                     score_method = 'ruleset1')
```

```{r}
opn4.1_recommended <- filter(opn4.1$pairs, opn4.1$pairs$recommended == TRUE)
kableExtra::scroll_box(knitr::kable(head(opn4.1_recommended,5)),width = '700px')
```

There is a basic plotting mode currently implemented for this type of gene, though this is mainly a placeholder and doesn't really convey any useful information yet.

#### Terminal exon PTCs

If a PTC occurs in the terminal exon of a gene, the PTC-bearing transcript is unlikely to induce NMD and subsequent compensation (an example of such an allele is the *sgsh^Δex5−6^* zebrafish mutant in [Douek et al., IJMS (2021)](#0 "An Engineered sgsh Mutant Zebrafish Recapitulates Molecular and Behavioural Pathobiology of Sanfilippo Syndrome A/MPS IIIA"){style="font-size: 11pt;"}). `mutateR` factors in predicted terminal exon PTCs when scanning for tolerated deletions, and flags these cases in the `run_mutateR` output in the `$pairs` dataframe, under the `terminal_exon_case` column.

## Manual function execution

You may wish to call lower-level functions directly (e.g., for use in other programmatic pipelines). Note, however, that many of these functions are built to take outputs from other `mutateR` functions.

### `get_gene_info()`

```{r}
tp53_geneinfo <- get_gene_info(gene_id = 'TP53',
                               species = 'hsapiens',
                               id_type = 'symbol')
tp53_geneinfo
```

### `get_exon_structures()`

```{r}
tp53_canonical_tx <- tp53_geneinfo$canonical$ensembl_transcript_id[1] 
tp53_exons <- get_exon_structures(transcript_id = tp53_canonical_tx,
                                  species = 'hsapiens',
                                  output = 'GRanges')
tp53_exons
```

### `find_cas9_sites()`

```{r}
tp53_cas9_sites <- find_cas9_sites(exon_gr = tp53_exons,
                                   genome = BSgenome.Hsapiens.UCSC.hg38,
                                   pam = 'NGG',
                                   protospacer_length = 20)
tp53_cas9_sites
```

### `find_cas12a_sites()`

```{r}
tp53_cas12a_sites <- find_cas12a_sites(exon_gr = tp53_exons,
                                       genome = BSgenome.Hsapiens.UCSC.hg38,
                                       pam = "TTTV",
                                       protospacer_length = 23)
tp53_cas12a_sites
```

### `score_grnas()`

N.B. Currently only working for Cas9 and `ruleset1`. More rulesets and nucleases to be implemented soon! Off-target analysis via `crisprScore` for Cas9 (`mit`, `cfd`) also to be implemented in future.

```{r}
tp53_cas9_gRNAs_scored <- score_grnas(grna_gr = tp53_cas9_sites,
                                      method = 'ruleset1')
tp53_cas9_gRNAs_scored
```

## To be implemented

-   More nucleases (maybe from CasPEDIA or similar?)

-   All `crisprScore` scoring methods

-   Visualisation improvements

-   Workflow for handling of intronic target sequences

## Session information

```{r}
sessionInfo()
```

## References

El-Brolosy, M. A. *et al.* Genetic compensation triggered by mutant mRNA degradation. *Nature* **568**, 193–197 (2019). <https://doi.org/10.1038/s41586-019-1064-z>

Hoberecht, L., Perampalam, P., Lun, A. & Fortin, J. P. A comprehensive Bioconductor ecosystem for the design of CRISPR guide RNAs across nucleases and technologies. *Nat Commun* **13**, 6568 (2022). <https://doi.org/10.1038/s41467-022-34320-7>

Lindeboom, R. G., Supek, F. & Lehner, B. The rules and impact of nonsense-mediated mRNA decay in human cancers. *Nat Genet* **48**, 1112–1118 (2016). <https://doi.org/10.1038/ng.3664>

Ma, Z. *et al.* PTC-bearing mRNA elicits a genetic compensation response via Upf3a and COMPASS components. *Nature* **568**, 259–263 (2019). <https://doi.org/10.1038/s41586-019-1057-y>

Douek, A. M. *et al.* An Engineered sgsh Mutant Zebrafish Recapitulates Molecular and Behavioural Pathobiology of Sanfilippo Syndrome A/MPS IIIA. *Int J Mol Sci* **22**, 5948 (2021). <https://doi.org/10.3390/ijms22115948>

Scott, D. A. & Zhang, F. Implications of human genetic variation in CRISPR-based therapeutic genome editing. *Nat Med* **23**, 1095–1101 (2017). <https://doi.org/10.1038/nm.4377>

Yang, W., Zhu, J. K. & Jin, W. A catalog of gene editing sites and genetic variations in editing sites in model organisms. *BMC Genomics* **25**, 1153 (2024). <https://doi.org/10.1186/s12864-024-11073-9>
