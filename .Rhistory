if (!activate_mutater_env()) stop("Env activation failed")
if (!file.exists(weights_file)) stop("Weights file not found")
encoded_data <- one_hot_encode_dna(sequence_context)
# !!! THIS SECTION WAS UPDATED TO MATCH THE .h5 FILE !!!
reticulate::py_run_string("
import tensorflow as tf
import numpy as np
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Conv1D, AveragePooling1D, Flatten, Dense, Dropout
def build_and_predict(weights_path, input_data):
try:
# Input: Sequence only (N, 34, 4)
input_seq = Input(shape=(34, 4))
# --- 1 Convolutional Layer ---
x = Conv1D(80, 5, padding='same', activation='relu')(input_seq)
x = AveragePooling1D(2)(x)
x = Flatten()(x)
# --- 3 Dense Layers + 1 Output = 4 Dense Layers ---
# Dense 1
x = Dense(80, activation='relu')(x)
x = Dropout(0.3)(x)
# Dense 2
x = Dense(40, activation='relu')(x)
x = Dropout(0.3)(x)
# Dense 3
x = Dense(40, activation='relu')(x)
x = Dropout(0.3)(x)
# Output
output = Dense(1, activation='linear')(x)
model = Model(inputs=input_seq, outputs=output)
print(f'Loading weights from: {weights_path}')
model.load_weights(weights_path)
# Predict
print('Running prediction...')
preds = model.predict(input_data, verbose=0)
return preds.flatten()
except Exception as e:
print(f'PYTHON ERROR: {e}')
return []
")
scores <- reticulate::py$build_and_predict(weights_file, encoded_data)
return(as.numeric(scores))
}
# --- EXECUTION ---
path_to_weights <- system.file("extdata", "Seq_deepCpf1_weights.h5", package = "mutateR")
if (path_to_weights == "") path_to_weights <- "./inst/extdata/Seq_deepCpf1_weights.h5"
result <- predict_deepcpf1_python_TEST(valid_seq, path_to_weights)
print("--- RESULT ---")
print(result)
library(reticulate)
# --- Define Input ---
valid_seq <- "AAAATTTCGCTAGCTAGCTAGCTAGCTAGCTGGG"
# --- Define Helpers ---
activate_mutater_env <- function(envname = "r-mutater") {
tryCatch({
reticulate::use_condaenv(envname, required = TRUE)
return(TRUE)
}, error = function(e) return(FALSE))
}
one_hot_encode_dna <- function(sequences) {
sequences <- toupper(sequences)
n_seqs <- length(sequences)
seq_len <- nchar(sequences[1])
char_vec <- unlist(strsplit(sequences, "", fixed = TRUE), use.names = FALSE)
char_mat <- matrix(char_vec, nrow = n_seqs, ncol = seq_len, byrow = TRUE)
x_encoded <- array(0, dim = c(n_seqs, seq_len, 4))
x_encoded[,,1] <- (char_mat == "A") * 1
x_encoded[,,2] <- (char_mat == "C") * 1
x_encoded[,,3] <- (char_mat == "G") * 1
x_encoded[,,4] <- (char_mat == "T") * 1
return(x_encoded)
}
# --- CORRECTED Prediction Function (Manual Weight Loading) ---
predict_deepcpf1_python_TEST <- function(sequence_context, weights_file) {
if (!activate_mutater_env()) stop("Env activation failed")
if (!file.exists(weights_file)) stop("Weights file not found")
encoded_data <- one_hot_encode_dna(sequence_context)
reticulate::py_run_string("
import tensorflow as tf
import numpy as np
import h5py
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Conv1D, AveragePooling1D, Flatten, Dense, Dropout
def build_and_predict(weights_path, input_data):
try:
# --- 1. Define Architecture ---
input_seq = Input(shape=(34, 4))
# Layer Index 1: Conv1D
x = Conv1D(80, 5, padding='same', activation='relu')(input_seq)
# Layer Index 2: Pool
x = AveragePooling1D(2)(x)
# Layer Index 3: Flatten
x = Flatten()(x)
# Layer Index 4: Dense 1
x = Dense(80, activation='relu')(x)
x = Dropout(0.3)(x)
# Layer Index 6: Dense 2
x = Dense(40, activation='relu')(x)
x = Dropout(0.3)(x)
# Layer Index 8: Dense 3
x = Dense(40, activation='relu')(x)
x = Dropout(0.3)(x)
# Layer Index 10: Output
output = Dense(1, activation='linear')(x)
model = Model(inputs=input_seq, outputs=output)
# --- 2. Manual Weight Loading ---
print(f'Reading weights from: {weights_path}')
with h5py.File(weights_path, 'r') as f:
# -- A. Load Convolutional Weights --
# Find key containing 'convolution1d'
conv_keys = [k for k in f.keys() if 'convolution1d' in k]
if not conv_keys: raise ValueError('No convolution layer found in .h5')
c_key = conv_keys[0]
conv_W = f[c_key][f'{c_key}_W'][()]
conv_b = f[c_key][f'{c_key}_b'][()]
# FIX: Squeeze the 4D weight (5, 1, 4, 80) -> (5, 4, 80)
if len(conv_W.shape) == 4:
conv_W = np.squeeze(conv_W, axis=1)
model.layers[1].set_weights([conv_W, conv_b])
# -- B. Load Dense Weights --
# Sort dense keys naturally: dense_490, dense_491, etc.
dense_keys = sorted([k for k in f.keys() if 'dense' in k])
# Map file keys to model layer indices
# [Dense1 (idx 4), Dense2 (idx 6), Dense3 (idx 8), Output (idx 10)]
layer_indices = [4, 6, 8, 10]
for i, d_key in enumerate(dense_keys):
if i >= len(layer_indices): break
target_idx = layer_indices[i]
dW = f[d_key][f'{d_key}_W'][()]
db = f[d_key][f'{d_key}_b'][()]
model.layers[target_idx].set_weights([dW, db])
# --- 3. Predict ---
print('Running prediction...')
preds = model.predict(input_data, verbose=0)
return preds.flatten()
except Exception as e:
print(f'PYTHON ERROR: {e}')
# Print stack trace for debugging
import traceback
traceback.print_exc()
return []
")
scores <- reticulate::py$build_and_predict(weights_file, encoded_data)
return(as.numeric(scores))
}
# --- EXECUTION ---
path_to_weights <- system.file("extdata", "Seq_deepCpf1_weights.h5", package = "mutateR")
if (path_to_weights == "") path_to_weights <- "./inst/extdata/Seq_deepCpf1_weights.h5"
result <- predict_deepcpf1_python_TEST(valid_seq, path_to_weights)
print("--- RESULT ---")
print(result)
library(reticulate)
# --- Define Input ---
valid_seq <- "AAAATTTCGCTAGCTAGCTAGCTAGCTAGCTGGG"
# --- Define Helpers ---
activate_mutater_env <- function(envname = "r-mutater") {
tryCatch({
reticulate::use_condaenv(envname, required = TRUE)
return(TRUE)
}, error = function(e) return(FALSE))
}
one_hot_encode_dna <- function(sequences) {
sequences <- toupper(sequences)
n_seqs <- length(sequences)
seq_len <- nchar(sequences[1])
char_vec <- unlist(strsplit(sequences, "", fixed = TRUE), use.names = FALSE)
char_mat <- matrix(char_vec, nrow = n_seqs, ncol = seq_len, byrow = TRUE)
x_encoded <- array(0, dim = c(n_seqs, seq_len, 4))
x_encoded[,,1] <- (char_mat == "A") * 1
x_encoded[,,2] <- (char_mat == "C") * 1
x_encoded[,,3] <- (char_mat == "G") * 1
x_encoded[,,4] <- (char_mat == "T") * 1
return(x_encoded)
}
# --- CORRECTED Prediction Function (Valid Padding + Manual Loading) ---
predict_deepcpf1_python_TEST <- function(sequence_context, weights_file) {
if (!activate_mutater_env()) stop("Env activation failed")
if (!file.exists(weights_file)) stop("Weights file not found")
encoded_data <- one_hot_encode_dna(sequence_context)
reticulate::py_run_string("
import tensorflow as tf
import numpy as np
import h5py
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Conv1D, AveragePooling1D, Flatten, Dense, Dropout
def build_and_predict(weights_path, input_data):
try:
# Input: Sequence only (N, 34, 4)
input_seq = Input(shape=(34, 4))
# --- FIX: padding='valid' ---
# 34bp -> (Conv valid, k=5) -> 30bp
x = Conv1D(80, 5, padding='valid', activation='relu')(input_seq)
# 30bp -> (Pool 2) -> 15bp
x = AveragePooling1D(2)(x)
# 15 * 80 = 1200 features
x = Flatten()(x)
x = Dense(80, activation='relu')(x)
x = Dropout(0.3)(x)
x = Dense(40, activation='relu')(x)
x = Dropout(0.3)(x)
x = Dense(40, activation='relu')(x)
x = Dropout(0.3)(x)
output = Dense(1, activation='linear')(x)
model = Model(inputs=input_seq, outputs=output)
# --- Manual Weight Loading ---
print(f'Reading weights from: {weights_path}')
with h5py.File(weights_path, 'r') as f:
# 1. Conv Weights
conv_keys = [k for k in f.keys() if 'convolution1d' in k]
if not conv_keys: raise ValueError('No convolution layer found')
c_key = conv_keys[0]
conv_W = f[c_key][f'{c_key}_W'][()]
conv_b = f[c_key][f'{c_key}_b'][()]
if len(conv_W.shape) == 4:
conv_W = np.squeeze(conv_W, axis=1)
model.layers[1].set_weights([conv_W, conv_b])
# 2. Dense Weights
dense_keys = sorted([k for k in f.keys() if 'dense' in k])
layer_indices = [4, 6, 8, 10] # Indices of Dense layers in new topology
for i, d_key in enumerate(dense_keys):
if i >= len(layer_indices): break
target_idx = layer_indices[i]
dW = f[d_key][f'{d_key}_W'][()]
db = f[d_key][f'{d_key}_b'][()]
model.layers[target_idx].set_weights([dW, db])
print('Running prediction...')
preds = model.predict(input_data, verbose=0)
return preds.flatten()
except Exception as e:
print(f'PYTHON ERROR: {e}')
import traceback
traceback.print_exc()
return []
")
scores <- reticulate::py$build_and_predict(weights_file, encoded_data)
return(as.numeric(scores))
}
# --- EXECUTION ---
path_to_weights <- system.file("extdata", "Seq_deepCpf1_weights.h5", package = "mutateR")
if (path_to_weights == "") path_to_weights <- "./inst/extdata/Seq_deepCpf1_weights.h5"
result <- predict_deepcpf1_python_TEST(valid_seq, path_to_weights)
print("--- RESULT ---")
print(result)
devtools::uninstall()
devtools::document()
devtools::install()
library(mutateR)
# Test 1c: Test1, but finding Cas12a gRNAs with DeepCpf1 scoring
test1c <- run_mutateR(gene_id = 'TP53',
species = 'hsapiens',
genome = BSgenome.Hsapiens.UCSC.hg38,
nuclease = 'Cas12a',
score_method = 'deepcpf1')
test1c$plot
View(test1c$pairs)
devtools::uninstall()
devtools::document()
devtools::install()
library(mutateR)
# Test 1c: Test1, but finding Cas12a gRNAs with DeepCpf1 scoring
test1c <- run_mutateR(gene_id = 'TP53',
species = 'hsapiens',
genome = BSgenome.Hsapiens.UCSC.hg38,
nuclease = 'Cas12a',
score_method = 'deepcpf1')
View(test1c$pairs)
View(test1)
View(test1[["pairs"]])
View(test1c$pairs)
devtools::uninstall()
devtools::document()
devtools::install()
library(mutateR)
rm(list = c("activate_mutater_env"))
devtools::uninstall()
devtools::document()
devtools::install()
library(mutateR)
test1 <- run_mutateR(gene_id = 'TP53',
species = 'hsapiens',
genome = BSgenome.Hsapiens.UCSC.hg38,
nuclease = 'Cas9',
score_method = 'ruleset1')
# Test 1a: Test 1, with interactive plot mode called
test1a <- run_mutateR(gene_id = 'TP53',
species = 'hsapiens',
genome = BSgenome.Hsapiens.UCSC.hg38,
nuclease = 'Cas9',
score_method = 'ruleset1',
interactive = T)
test1a$pairs
View(test1a$pairs)
# Test 1c: Test1, but finding Cas12a gRNAs with DeepCpf1 scoring
test1c <- run_mutateR(gene_id = 'TP53',
species = 'hsapiens',
genome = BSgenome.Hsapiens.UCSC.hg38,
nuclease = 'Cas12a',
score_method = 'deepcpf1')
View(test1c$pairs)
test1c$plot
check_mutater_env()
?check_mutater_env
# Test 1d: Test1c, but interactive plot mode evoked
test1d <- run_mutater(gene_id = 'TP53',
species = 'hsapiens',
genome = BSgenome.Hsapiens.UCSC.hg38,
nuclease = 'Cas12a',
score_method = 'deepcpf1',
interactive = T)
# Test 1d: Test1c, but interactive plot mode evoked
test1d <- run_mutater(gene_id = 'TP53',
species = 'hsapiens',
genome = BSgenome.Hsapiens.UCSC.hg38,
nuclease = 'Cas12a',
score_method = 'deepcpf1',
interactive = T)
# Test 1d: Test1c, but interactive plot mode evoked
test1d <- run_mutateR(gene_id = 'TP53',
species = 'hsapiens',
genome = BSgenome.Hsapiens.UCSC.hg38,
nuclease = 'Cas12a',
score_method = 'deepcpf1',
interactive = T)
test1d$plot
devtools::uninstall()
devtools::document()
devtools::install()
library(mutateR)
# Test 1a: Test 1, with interactive plot mode called
test1a <- run_mutateR(gene_id = 'TP53',
species = 'hsapiens',
genome = BSgenome.Hsapiens.UCSC.hg38,
nuclease = 'Cas9',
score_method = 'ruleset1',
interactive = T)
colnames(test1a$pairs)
# Test 1a: Test 1, with interactive plot mode called
test1a <- run_mutateR(gene_id = 'TP53',
species = 'hsapiens',
genome = BSgenome.Hsapiens.UCSC.hg38,
nuclease = 'Cas9',
score_method = 'ruleset1',
design_primers = TRUE,
primer_max_wt = 3000,
primer_tm = 60.0,
interactive = T)
colnames(test1a$pairs)
devtools::uninstall()
devtools::document()
devtools::install()
library(mutateR)
# Test 1a: Test 1, with interactive plot mode called
test1a <- run_mutateR(gene_id = 'TP53',
species = 'hsapiens',
genome = BSgenome.Hsapiens.UCSC.hg38,
nuclease = 'Cas9',
score_method = 'ruleset1',
design_primers = TRUE,
primer_max_wt = 3000,
primer_tm = 60.0,
interactive = T)
colnames(test1a$pairs)
devtools::uninstall()
devtools::document()
devtools::install()
library(mutateR)
# Test 1a: Test 1, with interactive plot mode called
test1a <- run_mutateR(gene_id = 'TP53',
species = 'hsapiens',
genome = BSgenome.Hsapiens.UCSC.hg38,
nuclease = 'Cas9',
score_method = 'ruleset1',
design_primers = TRUE,
primer_max_wt = 3000,
primer_tm = 60.0,
interactive = T)
head(test1a$pairs,0)
# Load dependencies
library(GenomicRanges)
library(Biostrings)
library(BSgenome.Hsapiens.UCSC.hg38)
# --- 1. Create Synthetic Exons (Chromosome 17 for TP53 context) ---
# We create 5 exons. Exon 3 will be the target for Strategy B internal primers.
mock_exons_gr <- GRanges(
seqnames = "chr17",
ranges = IRanges(
start = c(1000, 2000, 5000, 8000, 12000),
end   = c(1200, 2200, 5200, 8200, 12200)
),
strand = "-",
rank = 1:5
)
# --- 2. Create Synthetic Pairs DataFrame ---
mock_pairs <- data.frame(
# Common columns
seqnames_5p = "chr17",
# --- Case 1: Strategy A (Small Deletion, < 3kb) ---
# Deleting between Exon 1 and 2 (approx 800bp gap)
# Cut 5p at 1200, Cut 3p at 2000
case_id = c("Strat_A", "Strat_B", "Strat_B_Corrupt"),
cut_site_5p = c(1200, 2200, 2200),
cut_site_3p = c(2000, 8000, 8000),
# Strat A del = 800 | Strat B del = 5800
exon_5p = c(1, 2, 2),
exon_3p = c(2, 4, 4),
stringsAsFactors = FALSE
)
# --- 3. Run Strategy A Test ---
message("\n--- TEST 1: Strategy A (Small Deletion) ---")
tryCatch({
res_a <- get_genotyping_primers(
mock_pairs[1, ],
mock_exons_gr,
BSgenome.Hsapiens.UCSC.hg38,
max_wt_amplicon = 3000
)
print(res_a[, c("priming_strategy", "primer_ext_fwd", "exp_wt_size")])
message("SUCCESS: Strategy A executed.")
}, error = function(e) message("FAILURE: Strategy A crashed: ", e$message))
# --- 4. Run Strategy B Test (Clean Data) ---
message("\n--- TEST 2: Strategy B (Large Deletion, Clean) ---")
tryCatch({
res_b <- get_genotyping_primers(
mock_pairs[2, ],
mock_exons_gr,
BSgenome.Hsapiens.UCSC.hg38,
max_wt_amplicon = 3000
)
print(res_b[, c("priming_strategy", "primer_int_fwd", "exp_int_size")])
message("SUCCESS: Strategy B executed.")
}, error = function(e) message("FAILURE: Strategy B crashed: ", e$message))
# --- 5. Run Strategy B Test (Corrupt Internal Exon) ---
message("\n--- TEST 3: Strategy B (Corrupt/NA Exon Coordinates) ---")
# We modify the exon structure to have an NA for Exon 3 (the internal exon)
mock_exons_corrupt <- mock_exons_gr
# Force an NA into the start position of the exon expected to be picked as internal
start(mock_exons_corrupt)[3] <- NA
devtools::uninstall()
devtools::document()
devtools::install()
library(mutateR)
# Load dependencies
library(GenomicRanges)
library(Biostrings)
library(BSgenome.Hsapiens.UCSC.hg38)
# --- 1. Create Synthetic Exons (Chromosome 17 for TP53 context) ---
# We create 5 exons. Exon 3 will be the target for Strategy B internal primers.
mock_exons_gr <- GRanges(
seqnames = "chr17",
ranges = IRanges(
start = c(1000, 2000, 5000, 8000, 12000),
end   = c(1200, 2200, 5200, 8200, 12200)
),
strand = "-",
rank = 1:5
)
# --- 2. Create Synthetic Pairs DataFrame ---
mock_pairs <- data.frame(
# Common columns
seqnames_5p = "chr17",
# --- Case 1: Strategy A (Small Deletion, < 3kb) ---
# Deleting between Exon 1 and 2 (approx 800bp gap)
# Cut 5p at 1200, Cut 3p at 2000
case_id = c("Strat_A", "Strat_B", "Strat_B_Corrupt"),
cut_site_5p = c(1200, 2200, 2200),
cut_site_3p = c(2000, 8000, 8000),
# Strat A del = 800 | Strat B del = 5800
exon_5p = c(1, 2, 2),
exon_3p = c(2, 4, 4),
stringsAsFactors = FALSE
)
# --- 3. Run Strategy A Test ---
message("\n--- TEST 1: Strategy A (Small Deletion) ---")
tryCatch({
res_a <- get_genotyping_primers(
mock_pairs[1, ],
mock_exons_gr,
BSgenome.Hsapiens.UCSC.hg38,
max_wt_amplicon = 3000
)
print(res_a[, c("priming_strategy", "primer_ext_fwd", "exp_wt_size")])
message("SUCCESS: Strategy A executed.")
}, error = function(e) message("FAILURE: Strategy A crashed: ", e$message))
# --- 4. Run Strategy B Test (Clean Data) ---
message("\n--- TEST 2: Strategy B (Large Deletion, Clean) ---")
tryCatch({
res_b <- get_genotyping_primers(
mock_pairs[2, ],
mock_exons_gr,
BSgenome.Hsapiens.UCSC.hg38,
max_wt_amplicon = 3000
)
print(res_b[, c("priming_strategy", "primer_int_fwd", "exp_int_size")])
message("SUCCESS: Strategy B executed.")
}, error = function(e) message("FAILURE: Strategy B crashed: ", e$message))
# --- 5. Run Strategy B Test (Corrupt Internal Exon) ---
message("\n--- TEST 3: Strategy B (Corrupt/NA Exon Coordinates) ---")
# We modify the exon structure to have an NA for Exon 3 (the internal exon)
mock_exons_corrupt <- mock_exons_gr
# Force an NA into the start position of the exon expected to be picked as internal
start(mock_exons_corrupt)[3] <- NA
# Test 1a: Test 1, with interactive plot mode called
test1a <- run_mutateR(gene_id = 'TP53',
species = 'hsapiens',
genome = BSgenome.Hsapiens.UCSC.hg38,
nuclease = 'Cas9',
score_method = 'ruleset1',
design_primers = TRUE,
primer_max_wt = 3000,
primer_tm = 60.0,
interactive = T)
View(test1a$pairs)
