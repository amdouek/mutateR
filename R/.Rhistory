sequences_21mer = [s[:21] for s in valid_seqs]
# Load model (with caching by enzyme type)
cache_key = enzyme
if cache_key not in _DEEPHF_MODEL_CACHE:
with warnings.catch_warnings():
warnings.simplefilter('ignore')
_DEEPHF_MODEL_CACHE[cache_key] = load_model(model_path)
model = _DEEPHF_MODEL_CACHE[cache_key]
# Prepare inputs
X_seq = make_embedding_data(sequences_21mer)
X_bio = compute_biofeatures(sequences_21mer)
# Debug: Print features for verification
print(f'Sequence embedding shape: {X_seq.shape}')
print(f'Bio features shape: {X_bio.shape}')
print(f'First sequence 21-mer: {sequences_21mer[0]}')
print(f'First sequence bio features: {X_bio[0]}')
# Predict
predictions = model.predict([X_seq, X_bio], verbose=0)
# Clip to 0-1 range (matching original)
predictions = np.clip(predictions.flatten(), 0, 1)
# Reconstruct full array with NaNs for invalid sequences
if len(valid_seqs) == len(sequences):
return predictions
else:
full_scores = np.full(len(sequences), np.nan)
valid_idx = 0
for i, v in enumerate(valid_mask):
if v:
full_scores[i] = predictions[valid_idx]
valid_idx += 1
return full_scores
except Exception as e:
print(f'DeepHF PYTHON BACKEND ERROR: {e}')
import traceback
traceback.print_exc()
return np.array([])
")
}
# --- 6. Run inference ---
scores <- reticulate::py$predict_deephf(
model_path = weights_file,
sequences = as.list(sequence_context),
enzyme = deephf_var
)
if (length(scores) == 0) {
warning("DeepHF inference failed (returned 0 scores).")
return(rep(NA_real_, length(sequence_context)))
}
return(as.numeric(scores))
}
#' Validate DeepHF installation
#'
#' Tests that the DeepHF models and ViennaRNA dependency are correctly installed.
#'
#' @param deephf_var Character. Model variant to test (default "wt_u6").
#'
#' @return Logical; TRUE if DeepHF is working correctly, FALSE otherwise.
#' @export
validate_deephf <- function(deephf_var = "wt_u6") {
if (!requireNamespace("reticulate", quietly = TRUE)) {
message("reticulate package not available.")
return(FALSE)
}
if (!check_mutater_env()) {
if (!activate_mutater_env()) {
message("Could not activate mutateR environment.")
return(FALSE)
}
}
# Check ViennaRNA
if (!reticulate::py_module_available("RNA")) {
message("ViennaRNA Python module ('RNA') not found in current Python environment.")
message("Please reinstall the environment: install_mutater_env(fresh = TRUE)")
return(FALSE)
}
# Check TensorFlow
if (!reticulate::py_module_available("tensorflow")) {
message("TensorFlow not found in current Python environment.")
return(FALSE)
}
# Test with known sequences
tryCatch({
# Test sequences (23bp: 20bp protospacer + NGG)
test_seqs <- c(
"ACGTGTGACTACCGGCGGCGCGG",
"GGAAGTCTGGAGTCTCCAGGTGG"
)
scores <- predict_deephf_python(test_seqs, deephf_var = deephf_var)
if (length(scores) == 2 && is.numeric(scores) && !any(is.na(scores))) {
message("DeepHF installation validated successfully.")
message(sprintf("Model variant: %s", deephf_var))
message(sprintf("Test scores: %.4f, %.4f", scores[1], scores[2]))
return(TRUE)
} else {
message("DeepHF returned unexpected output.")
return(FALSE)
}
}, error = function(e) {
message(sprintf("DeepHF validation failed: %s", e$message))
return(FALSE)
})
}
#' Get DeepHF model recommendation based on experimental design
#'
#' Helper function to guide users in selecting the appropriate DeepHF model
#' variant based on their experimental design.
#'
#' @param delivery Character. gRNA delivery method. One of:
#'        "plasmid", "lentiviral", "rnp_ivt", "rnp_synthetic", "unknown".
#' @param cas9_variant Character. Cas9 variant being used. One of:
#'        "wt", "eSpCas9", "SpCas9-HF1".
#'
#' @return Character. Recommended DeepHF model variant.
#'
#' @examples
#' \dontrun{
#' # Plasmid transfection with WT Cas9
#' recommend_deephf_model("plasmid", "wt")
#' # Returns: "wt_u6"
#'
#' # RNP delivery with synthetic gRNA
#' recommend_deephf_model("rnp_synthetic", "wt")
#' # Returns: "wt_t7"
#' }
#'
#' @export
recommend_deephf_model <- function(delivery = c("plasmid", "lentiviral", "rnp_ivt",
"rnp_synthetic", "unknown"),
cas9_variant = c("wt", "eSpCas9", "SpCas9-HF1")) {
delivery <- match.arg(delivery)
cas9_variant <- match.arg(cas9_variant)
# High-fidelity variants override delivery method
if (cas9_variant == "eSpCas9") {
message("Recommendation: 'esp' model for eSpCas9(1.1)")
message("Note: This model was trained on eSpCas9(1.1) activity data.")
return("esp")
}
if (cas9_variant == "SpCas9-HF1") {
message("Recommendation: 'hf' model for SpCas9-HF1")
message("Note: This model was trained on SpCas9-HF1 activity data.")
return("hf")
}
# WT Cas9 - select based on delivery method
recommendation <- switch(delivery,
"plasmid" = {
message("Recommendation: 'wt_u6' model for plasmid-based delivery")
message("Note: Optimized for U6 promoter-driven gRNA expression in mammalian cells.")
"wt_u6"
},
"lentiviral" = {
message("Recommendation: 'wt_u6' model for lentiviral delivery")
message("Note: Optimized for U6 promoter-driven gRNA expression in mammalian cells.")
"wt_u6"
},
"rnp_ivt" = {
message("Recommendation: 'wt_t7' model for RNP delivery with IVT gRNA")
message("Note: Optimized for T7 promoter-driven in vitro transcribed gRNAs.")
"wt_t7"
},
"rnp_synthetic" = {
message("Recommendation: 'wt_t7' model for RNP delivery with synthetic gRNA")
message("Note: T7 model is the best available approximation for synthetic gRNAs,")
message("      though neither U6 nor T7 models were specifically trained on this context.")
"wt_t7"
},
"unknown" = {
message("Recommendation: 'wt_u6' model (default)")
message("Note: U6 model is recommended as default for mammalian cell experiments.")
message("      Consider 'wt_t7' if using RNP delivery or in vitro transcribed gRNAs.")
"wt_u6"
}
)
return(recommendation)
}
test_seqs <- c("ACGTGTGACTACCGGCGGCGCGG", "GGAAGTCTGGAGTCTCCAGGTGG")
scores <- predict_deephf_python(test_seqs, deephf_var = "wt_u6")
# Expected: ~0.62 and ~0.71
rm(scores)
test_seqs <- c("ACGTGTGACTACCGGCGGCGCGG", "GGAAGTCTGGAGTCTCCAGGTGG")
scores <- predict_deephf_python(test_seqs, deephf_var = "wt_u6")
# Expected: ~0.62 and ~0.71
# Load the package / source the updated file
# devtools::load_all() or source("R/score_deephf.R")
# Activate environment
activate_mutater_env()
# Test sequences (23bp: 20bp protospacer + 3bp PAM)
test_seqs <- c("ACGTGTGACTACCGGCGGCGCGG", "GGAAGTCTGGAGTCTCCAGGTGG")
# Run prediction
scores <- predict_deephf_python(test_seqs, deephf_var = "wt_u6")
# Print results
print(scores)
devtools::document()
devtools::install()
library(mutateR)
library(BSgenome.Hsapiens.UCSC.hg38)
# Test 1c: Test1, but finding Cas12a gRNAs with DeepCpf1 scoring and primer design for recommended gRNA pairs
library(reticulate)
activate_mutater_env()
#' @param deephf_var Character. One of "wt", "wt_u6" (default), "wt_t7", "esp", or "hf".
#'
#' @return Numeric vector of on-target efficiency scores (0-1 scale).
#'
#' @references
#' Wang, D., Zhang, C., Wang, B., Li, B., Wang, Q., Liu, D., ... & Wang, Y. (2019).
#' Optimized CRISPR guide RNA design for two high-fidelity Cas9 variants by deep learning.
#' Nature Communications, 10(1), 4284. \doi{10.1038/s41467-019-12281-8}
#'
#' @noRd
predict_deephf_python <- function(sequence_context,
deephf_var = c("wt_u6", "wt_t7", "wt", "esp", "hf")) {
# --- 1. Input validation ---
deephf_var <- match.arg(deephf_var)
if (is.null(sequence_context) || length(sequence_context) == 0) {
return(numeric(0))
}
if (!requireNamespace("reticulate", quietly = TRUE)) {
stop("reticulate package is required.")
}
# --- 2. Validate and process sequence lengths ---
seq_lengths <- nchar(sequence_context)
# Accept either 23bp (protospacer+PAM) or 30bp (full context)
if (all(seq_lengths == 30)) {
# Trim 30bp context to 23bp: remove 4bp 5' flank and 3bp 3' flank
message("Detected 30bp context sequences. Trimming to 23bp (protospacer + PAM).")
sequence_context <- substring(sequence_context, 5, 27)
} else if (all(seq_lengths == 23)) {
# Already correct format
} else {
bad_idx <- which(seq_lengths != 23 & seq_lengths != 30)
warning("DeepHF requires 23bp (protospacer+PAM) or 30bp context sequences. ",
length(bad_idx), " sequences have incorrect length. Returning NAs for those.")
}
# --- 3. Environment setup ---
if (!check_mutater_env()) {
if (!activate_mutater_env()) {
stop("Could not activate mutateR Python environment. Please run install_mutater_env().")
}
}
# Check ViennaRNA availability
if (!reticulate::py_module_available("RNA")) {
stop("ViennaRNA Python module ('RNA') is not available.\n",
"Please reinstall the environment: install_mutater_env(fresh = TRUE)")
}
# --- 4. Locate model weights ---
weight_files <- list(
wt    = "DeepWt.hd5",
wt_u6 = "DeepWt_U6.hd5",
wt_t7 = "DeepWt_T7.hd5",
esp   = "esp_rnn_model.hd5",
hf    = "hf_rnn_model.hd5"
)
weights_file <- system.file("extdata", weight_files[[deephf_var]], package = "mutateR")
if (weights_file == "") {
# Fallback for dev environments
dev_path <- file.path("./inst/extdata", weight_files[[deephf_var]])
if (file.exists(dev_path)) {
weights_file <- dev_path
} else {
stop("DeepHF weights file '", weight_files[[deephf_var]], "' not found in package extdata directory.")
}
}
# --- 5. Define Python backend ---
is_defined <- tryCatch({
reticulate::py_eval("'predict_deephf' in globals()")
}, error = function(e) FALSE)
if (!is_defined) {
reticulate::py_run_string("
import numpy as np
import pandas as pd
import warnings
import RNA
import tensorflow as tf
from tensorflow.keras.preprocessing import sequence as keras_sequence
from tensorflow.keras.models import load_model
from Bio.SeqUtils import MeltingTemp as Tm
# ============================================================================
# MODEL CACHE
# ============================================================================
_DEEPHF_MODEL_CACHE = {}
# ============================================================================
# SEQUENCE EMBEDDING
# ============================================================================
def make_embedding_data(sequences):
'''
Convert DNA sequences to integer-encoded arrays for embedding layer.
Matches original make_data() function exactly.
'''
char_dict = {'A': 2, 'T': 3, 'C': 4, 'G': 5}
encoded = []
for seq in sequences:
seq_encoded = [1]  # START token
for char in seq.upper():
seq_encoded.append(char_dict.get(char, 0))
encoded.append(seq_encoded)
X = keras_sequence.pad_sequences(encoded, maxlen=22, padding='pre', value=0)
return np.array(X)
# ============================================================================
# BIOLOGICAL FEATURES - CORRECTED
# ============================================================================
def dG_binding(seq):
'''
Calculate DNA:RNA binding free energy using nearest-neighbor model.
Matches original exactly.
'''
seq = seq.lower().replace('u', 't')
dG_nn = {
'aa': -0.2, 'tt': -1.0, 'at': -0.9, 'ta': -0.6,
'ca': -1.6, 'tg': -0.9, 'ct': -1.8, 'ag': -0.9,
'ga': -1.5, 'tc': -1.3, 'gt': -2.1, 'ac': -1.1,
'cg': -1.7, 'gc': -2.7, 'gg': -2.1, 'cc': -2.9
}
dGi = 3.1  # Initiation energy
binding_dG = dGi
for i in range(len(seq) - 1):
dinuc = seq[i:i+2]
binding_dG += dG_nn.get(dinuc, 0)
return binding_dG
def get_structure_features(seq_21mer):
'''
Calculate RNA secondary structure features using ViennaRNA.
CRITICAL FIX:
- dG comes from folding the 20-mer ALONE
- stem comes from folding the 99-mer (20mer + 79bp scaffold)
This matches the original implementation which calls RNAfold twice.
'''
# Original scaffold is 79 characters
scaffold_seq = 'GTTTTAGAGCTAGAAATAGCAAGTTAAAATAAGGCTAGTCCGTTATCAACTTGAAAAAGTGGCACCGAGTCGGTGCTTT'
# Get 20-mer (protospacer only, excluding PAM nucleotide)
seq_20mer = seq_21mer[:20].upper()
# Convert to RNA for ViennaRNA
rna_20mer = seq_20mer.replace('T', 'U')
scaffold_rna = scaffold_seq.replace('T', 'U')
# FOLD 1: 20-mer alone to get dG
# This matches the original: 'lst_0 = get_dG( bytes_list )[0]' which folds just the 20-mer
(structure_20, dG) = RNA.fold(rna_20mer)
# FOLD 2: 99-mer (20bp + 79bp scaffold) to get stem structure
# This matches the original: 'lst_1 = get_dG( bytes_list )[1]' which folds the full 99-mer
full_rna = rna_20mer + scaffold_rna
(structure_99, mfe_99) = RNA.fold(full_rna)
# Check for canonical stem-loop structure in the 99-mer fold
# Original: align_seq = c[1][:99]; aligned_stem = align_seq[18:18+len(ext_stem)]
ext_stem = '(((((((((.((((....))))...)))))))'
aligned_stem = structure_99[18:18+len(ext_stem)] if len(structure_99) >= 18+len(ext_stem) else ''
stem = 1 if ext_stem == aligned_stem else 0
# Calculate binding energies
# Original: dG_binding_20 = dG_binding( a[0][1:21] ) where a[0] is FASTA header '>'+21mer
# So a[0][1:21] = first 20 chars of 21mer = the 20-mer
dG_binding_20 = dG_binding(seq_20mer)
# Original: dg_binding_7to20 = dG_binding( a[0][8:21] )
# a[0][8:21] = positions 7-19 of the 21mer = 13 nucleotides
dG_binding_7to20 = dG_binding(seq_21mer[7:20])
return stem, dG, dG_binding_20, dG_binding_7to20
def get_gc_features(seq_21mer):
'''
Calculate GC content features.
Original: countGC counts G+C in first 20 positions only.
'''
seq_20mer = seq_21mer[:20].upper()
gc_count = seq_20mer.count('G') + seq_20mer.count('C')
gc_above_10 = 1 if gc_count > 10 else 0
gc_below_10 = 1 if gc_count < 10 else 0
return gc_above_10, gc_below_10, gc_count
def get_tm_features(seq_21mer):
'''
Calculate melting temperature features.
Original uses Tm.Tm_staluc(seq, rna=False) which is deprecated.
Tm_staluc used SantaLucia 1998 unified parameters.
Segments from original: [(15, 21), (4, 13), (0, 4)]
'''
seq = seq_21mer.upper()
def calc_tm_staluc(s):
'''Replicate Tm_staluc behavior as closely as possible'''
if len(s) < 2:
return 0.0
try:
# Tm_staluc used SantaLucia unified parameters (1998)
# with default dnac=50nM, saltc=50mM
return Tm.Tm_NN(
s,
nn_table=Tm.DNA_NN3,  # Allawi & SantaLucia 1997
dnac1=50,
dnac2=50,
Na=50,
saltcorr=5
)
except Exception:
return 0.0
# Original segments: Tm_staluc(seq), seq[15:21], seq[4:13], seq[0:4]
Tm_global = calc_tm_staluc(seq)            # Full 21-mer
Tm_5mer_end = calc_tm_staluc(seq[15:21])   # 6 nucleotides proximal to PAM
Tm_8mer_middle = calc_tm_staluc(seq[4:13]) # 9 nucleotides in middle
Tm_4mer_start = calc_tm_staluc(seq[0:4])   # 4 nucleotides at start
return Tm_global, Tm_5mer_end, Tm_8mer_middle, Tm_4mer_start
def compute_biofeatures(sequences_21mer):
'''
Compute all 11 biological features for a batch of sequences.
Feature order matches original lst_features = [0, 1, 2, 3, -7, -6, -5, -4, -3, -2, -1]:
Index 0: stem
Index 1: dG (from 20-mer fold - CRITICAL)
Index 2: dG_binding_20
Index 3: dG_binding_7to20
Index 4: GC > 10
Index 5: GC < 10
Index 6: GC count
Index 7: Tm global
Index 8: Tm 5mer_end
Index 9: Tm 8mer_middle
Index 10: Tm 4mer_start
'''
n_seqs = len(sequences_21mer)
features = np.zeros((n_seqs, 11))
for i, seq in enumerate(sequences_21mer):
seq = seq.upper()
# Structure features (indices 0-3)
stem, dG, dG_20, dG_7to20 = get_structure_features(seq)
features[i, 0] = stem
features[i, 1] = dG    # This is now from 20-mer fold
features[i, 2] = dG_20
features[i, 3] = dG_7to20
# GC features (indices 4-6)
gc_above, gc_below, gc_count = get_gc_features(seq)
features[i, 4] = gc_above
features[i, 5] = gc_below
features[i, 6] = gc_count
# Tm features (indices 7-10)
tm_global, tm_5mer, tm_8mer, tm_4mer = get_tm_features(seq)
features[i, 7] = tm_global
features[i, 8] = tm_5mer
features[i, 9] = tm_8mer
features[i, 10] = tm_4mer
return features
# ============================================================================
# MODEL LOADING AND PREDICTION
# ============================================================================
def predict_deephf(model_path, sequences, enzyme):
'''
Load DeepHF model and predict on-target efficiency scores.
'''
global _DEEPHF_MODEL_CACHE
try:
# Validate sequences (expect 23bp: 20bp protospacer + 3bp PAM)
valid_mask = [len(s) == 23 for s in sequences]
valid_seqs = [s.upper() for s, v in zip(sequences, valid_mask) if v]
if len(valid_seqs) == 0:
return np.array([np.nan] * len(sequences))
# Extract 21-mers (protospacer + first PAM nucleotide)
sequences_21mer = [s[:21] for s in valid_seqs]
# Load model (with caching by enzyme type)
cache_key = enzyme
if cache_key not in _DEEPHF_MODEL_CACHE:
with warnings.catch_warnings():
warnings.simplefilter('ignore')
_DEEPHF_MODEL_CACHE[cache_key] = load_model(model_path)
model = _DEEPHF_MODEL_CACHE[cache_key]
# Prepare inputs
X_seq = make_embedding_data(sequences_21mer)
X_bio = compute_biofeatures(sequences_21mer)
# Debug: Print features for verification
print(f'Sequence embedding shape: {X_seq.shape}')
print(f'Bio features shape: {X_bio.shape}')
print(f'First sequence 21-mer: {sequences_21mer[0]}')
print(f'First sequence bio features: {X_bio[0]}')
# Predict
predictions = model.predict([X_seq, X_bio], verbose=0)
# Clip to 0-1 range (matching original)
predictions = np.clip(predictions.flatten(), 0, 1)
# Reconstruct full array with NaNs for invalid sequences
if len(valid_seqs) == len(sequences):
return predictions
else:
full_scores = np.full(len(sequences), np.nan)
valid_idx = 0
for i, v in enumerate(valid_mask):
if v:
full_scores[i] = predictions[valid_idx]
valid_idx += 1
return full_scores
except Exception as e:
print(f'DeepHF PYTHON BACKEND ERROR: {e}')
import traceback
traceback.print_exc()
return np.array([])
")
}
# --- 6. Run inference ---
scores <- reticulate::py$predict_deephf(
model_path = weights_file,
sequences = as.list(sequence_context),
enzyme = deephf_var
)
if (length(scores) == 0) {
warning("DeepHF inference failed (returned 0 scores).")
return(rep(NA_real_, length(sequence_context)))
}
return(as.numeric(scores))
}
test_seqs <- c("ACGTGTGACTACCGGCGGCGCGG", "GGAAGTCTGGAGTCTCCAGGTGG")
scores <- predict_deephf_python(test_seqs, deephf_var = "wt_u6")
print(scores)
gc()
test1e <- run_mutateR(gene_id = 'TP53',
species = 'hsapiens',
genome = BSgenome.Hsapiens.UCSC.hg38,
nuclease = 'Cas9',
score_method = 'deephf',
deephf_var = 'wt_u6',
design_primers = T,
primer_max_wt = 3000,
primer_tm = 60.0,
interactive = T)
test1e$plot
View(test1e$pairs)
